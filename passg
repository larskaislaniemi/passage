#!/usr/bin/sh

set -eu -o noglob


### CONFIG VARIABLES

DIRSUFFIX="passg"
SIGNATURE_NAMESPACE="passg"
TMPROOT="/dev/shm"
TMPDIR="/dev/shm" # modified on start
LOGFILE="${TMPDIR}/passg.log" # modified on start
EDITOR=${EDITOR:-vi} # YES!
ROOTDIR="." # modified by command line arguments

MYSECKEY="" #"${HOME}/.ssh/id_ed25519"
MYPUBKEY="" # default value modified on start
MYALLOWEDSIGNERS="" #"${HOME}/.config/passg/allowed_signers"

SAFE_UMASK="077"

### RUNTIME GLOBAL VARIABLES

STATE_RUNDIR="/tmp" # modified on start
STATE_UMASK="777" # modified on start
SAVELOG="0"


### HELPER ROUTINES

passg__shred_recursive() {
	# arguments:
	# - dir/filename
	# output: none
	# returns via exit(), run in a subshell!

	local f="$1"
	local dummy
	local frec

	if [ -f "$f" ]; then
		shred "$f"
		rm -f "$f"
		exit 0
	fi

	if [ -d "$f" ]; then
		local d=$(realpath "$f")
		local n=$(find "$f" -type f | wc -l)

		if [ "$n" -gt 10 ]; then
			echo "WARNING: Skipping shredding of $f -- too many files" >&2
			exit 1
		fi

		if [ "$d" = "/" ]; then
			echo "WARNING: Skipping shredding of $f -- it's the root..." >&2
			exit 1
		fi

		find "$d" -type f | while read frec; do
			shred "$frec"
			rm -f "$frec"
		done

		rm -fr "$d"

		exit 0
	fi

	exit 1
}

passg__sighandler() {
	if [ "$SAVELOG" -eq "1" ]; then
		if [ -f "$LOGFILE" ]; then
			cp "$LOGFILE" "$TMPROOT/"
			echo "Log file saved at ${TMPROOT}/$(basename "$LOGFILE")" >&2
		else
			echo "No log file to save" >&2
		fi
	fi
	(passg__shred_recursive "$TMPDIR") || echo "Failed to clean $TMPDIR" >&2
	cd "$STATE_RUNDIR"
	umask "$STATE_UMASK"
}

passg__require_pubkey() {
	# arguments: none
	# uses global MYPUBKEY

	if [ "$MYPUBKEY" = "" ]; then
		echo "Required public key file not set" >&2
		return 1
	fi

	if [ ! -f "$MYPUBKEY" ]; then
		echo "Required public key file not found, tried: $MYPUBKEY" >&2
		return 1
	fi

	return 0
}

passg__require_seckey() {
	# arguments: none
	# uses global MYSECKEY

	if [ "$MYSECKEY" = "" ]; then
		echo "Required secret key file not set" >&2
		return 1
	fi

	if [ ! -f "$MYSECKEY" ]; then
		echo "Required secret key file not found, tried: $MYSECKEY" >&2
		return 1
	fi

	return 0
}

passg__require_allowedsigners() {
	# arguments: none
	# uses global MYALLOWEDSIGNERS

	if [ "$MYALLOWEDSIGNERS" = "" ]; then
		echo "Required allowed signers file not set" >&2
		return 1
	fi

	if [ ! -f "$MYALLOWEDSIGNERS" ]; then
		echo "Required allowed signers file not found, tried: $MYALLOWEDSIGNERS" >&2
		return 1
	fi

	return 0
}

passg__normal_umask() {
	umask "$STATE_UMASK"
}

passg__safe_umask() {
	umask "$SAFE_UMASK"
}


### ATOMIC OPERATIONS

passg_encrypt_secret() {
	# arguments:
	# - secretname
	# - recipients filename

	local secretname="$1"
	local recipients_filename="$2"
	local tmpcreate
	
	# TODO: check existence / lock file; might also be open for myself

	passg__require_seckey

	passg__safe_umask
	tmpcreate=$(mktemp -d -p "$TMPDIR")

	cat "$recipients_filename" > "${tmpcreate}/recips"
	ssh-keygen -Y sign -f "${MYSECKEY}" -n "${SIGNATURE_NAMESPACE}" \
		"${tmpcreate}/recips" \
		> "$LOGFILE" 2> "$LOGFILE" || {
		echo "ERROR: Signing of recipients file failed" >&2
		return 1
	}
	age -R "${recipients_filename}" > "${tmpcreate}/secret" \
		2> "$LOGFILE" || {
		echo "ERROR: Encryption of secret failed" >&2
		return 1
	}

	passg__normal_umask
	mkdir -p "${secretname}.${DIRSUFFIX}"
	for f in recips recips.sig secret; do
		rm -f "${secretname}.${DIRSUFFIX}/${f}"
		cat "${tmpsecret}/${f}" > "${secretname}.${DIRSUFFIX}/"
	done

	passg__safe_umask

	return 0
}

passg_show_secret() {
	# arguments:
	# - secretname

	local secretname="$1"

	passg__require_seckey 

	age --decrypt -i "${MYSECKEY}" "${secretname}.${DIRSUFFIX}/secret" \
		2> "$LOGFILE" || {
		echo "ERROR: Decryption of secret failed" >&2
		return 1
	}

	return 0
}

passg_show_recipients() {
	# arguments
	# - secretname

	local signedprincipal
	local isvalidsig="0"
	local secretname="$1"

	passg__require_allowedsigners 

	signedprincipal=$(ssh-keygen -Y find-principals \
		-s "${secretname}.${DIRSUFFIX}/recips.sig" \
		-f "${MYALLOWEDSIGNERS}" 2> "$LOGFILE") || {
		echo "ERROR: Couldn't find the signer's principal in allowed signers list" >&2
		return 1
	}

	ssh-keygen -Y verify -f "${MYALLOWEDSIGNERS}" -I "${signedprincipal}" \
		-n "${SIGNATURE_NAMESPACE}" -s "${secretname}.${DIRSUFFIX}/recips.sig" \
		> "$LOGFILE" 2> "$LOGFILE" < "${secretname}.${DIRSUFFIX}/recips" \
		&& isvalidsig="1"
	# TODO: use option -r revocation_file for ssh-keygen -Y verify

	if [ "$isvalidsig" -ne "1" ]; then
		echo "ERROR: Could not verify signature for recipients list" >&2
		return 1
	fi

	cat "${secretname}.${DIRSUFFIX}/recips"
	
	return 0
}

passg__open_secret() {
	# arguments
	# - secretname
	# output: tmpdir location
	# returns via exit(), run in subshell!

	local secretname="$1"
	local tmpsecret

	passg__safe_umask # just to be sure

	tmpsecret="$(mktemp -d -p "$TMPDIR")"

	# Make sure we give the output before
	# potentially exiting due to an error
	echo "$tmpsecret"
	
	passg_show_recipients "$secretname" > "${tmpsecret}/recips" 
	passg_show_secret "$secretname" > "${tmpsecret}/secret.plain" 

	exit 0

	# TODO: add lockfile
}

passg__close_secret() {
	# arguments:
	# - tmpdir location
	# output: none
	# returns via exit(), run in subshell!

	local tmpsecret="$1"

	(passg__shred_recursive "$tmpsecret") || {
		echo "WARNING: Failed to clean $tmpsecret" >&2
		exit 1
	}

	exit 0
	# TODO: remove lockfile
}


### COMBINED OPERATIONS

passg_update_secret() {
	# arguments
	# - secretname

	local secretname="$1"
	local tmpsecret
	tmpsecret=$(passg__open_secret "$secretname") 

	cat > "${tmpsecret}/secret.plain"

	passg_encrypt_secret "$secretname" "${tmpsecret}/recips" \
		< "${tmpsecret}/secret.plain"

	passg__close_secret "$tmpsecret" 
}

passg_modify_secret() {
	# arguments
	# - secretname

	local secretname="$1"
	local tmpsecret
	tmpsecret=$(passg__open_secret "$secretname") 

	"$EDITOR" "${tmpsecret}/secret.plain"

	passg_encrypt_secret "$secretname" "${tmpsecret}/recips" \
		< "${tmpsecret}/secret.plain"

	passg__close_secret "$tmpsecret" 
}

passg_update_recipients() {
	# arguments
	# - secretname

	local secretname="$1"
	local tmpsecret
	tmpsecret=$(passg__open_secret "$secretname") 

	cat > "${tmpsecret}/recips"

	passg_encrypt_secret "$secretname" "${tmpsecret}/recips" \
		< "${tmpsecret}/secret.plain"

	passg__close_secret "$tmpsecret" 
}

passg_modify_recipients() {
	# arguments
	# - secretname

	local secretname="$1"
	local tmpsecret
	tmpsecret=$(passg__open_secret "$secretname")

	"$EDITOR" "${tmpsecret}/recips"

	passg_encrypt_secret "$secretname" "${tmpsecret}/recips" \
		< "${tmpsecret}/secret.plain"

	passg__close_secret "$tmpsecret" 
}


### OTHER SUBROUTINES

passg_list_secrets() {
	# arguments: none

	find "$ROOTDIR" -type d -name "*.${DIRSUFFIX}" | while read d; do
		if [ -f "${d}/secret" ] && [ -f "${d}/recips" ]; then
			local path
			path=${d#"${ROOTDIR}/"}
			path=${path%".${DIRSUFFIX}"}
			echo "${path}"
		else
			continue
		fi
	done
}

passg_usage() {
	echo "Usage: not yet implemented"
}


############
### MAIN ###
############

TMPDIR="$(mktemp -d -p "$TMPROOT")"
LOGFILE="${TMPDIR}/passg.log"
STATE_RUNDIR=$(pwd)
STATE_UMASK=$(umask)


umask "$SAFE_UMASK"
trap passg__sighandler EXIT


# Command line options - parsing

while getopts 'R:k:p:s:' arg; do
	case $arg in
	k)
		MYSECKEY="$OPTARG"
		;;
	p)
		MYPUBKEY="$OPTARG"
		;;
	R) 
		ROOTDIR="$OPTARG"
		;;
	s)
		MYALLOWEDSIGNERS="$OPTARG"
		;;
	*)
		passg_usage
		exit 1
		;;
	esac
done
shift $((OPTIND-1))


# Options - sanity check
# - sanity of private / public key filenames is checked ad-hoc
# - public key location is guessed here if unset
# - sanity of allowed-signers file is checked ad-hoc

if [ "$MYPUBKEY" = "" ] && [ -f "$MYSECKEY" ]; then
	if [ -f "${MYSECKEY}.pub" ]; then
		MYPUBKEY="${MYSECKEY}.pub"
		echo "Using implicit public key $MYPUBKEY" >&2
	fi
fi

if [ ! -d "$ROOTDIR" ]; then
	echo "Root dir is not a directory" >&2
	exit 1
fi
ROOTDIR=$(realpath $ROOTDIR)
ROOTDIR="${ROOTDIR%"/"}"


# Prepare environment

cd "$ROOTDIR"


# Parse commands

if [ "$#" -lt 1 ]; then
	passg_usage
	exit 1
fi

cmd="$1"
shift

case "$cmd" in
encrypt-secret)
	passg_encrypt_secret $@ 
	;;
show-secret)
	passg_show_secret $@ 
	;;
show-recipients)
	passg_show_recipients $@
	;;
list-secrets)
	passg_list_secrets $@ 
	;;
modify-secret)
	passg_modify_secret $@
	;;
update-secret)
	passg_update_secret $@
	;;
modify-recipients)
	passg_modify_recipients $@ 
	;;
update-recipients)
	passg_update_recipients $@ 
	;;
*)
	echo "Unknown command $cmd"
	passg_usage $@
	exit 1
	;;
esac

